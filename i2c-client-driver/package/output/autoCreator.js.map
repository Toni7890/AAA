{"version":3,"file":"autoCreator.js","mappings":"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","sources":["webpack://autoCreator/./node_modules/@microchip/i2c-client-basic-drv-interface/lib/src/i2c-client-basic-drv-interface.js","webpack://autoCreator/./node_modules/@microchip/i2c-client-basic-drv-interface/lib/src/index.js","webpack://autoCreator/./node_modules/@microchip/i2c-client-basic/lib/src/api.js","webpack://autoCreator/./node_modules/@microchip/i2c-client-basic/lib/src/i2c-client-basic.js","webpack://autoCreator/./node_modules/@microchip/i2c-client-basic/lib/src/index.js","webpack://autoCreator/./node_modules/@microchip/scf-interface/lib/c-function-types.js","webpack://autoCreator/./node_modules/@microchip/scf-interface/lib/helpers.js","webpack://autoCreator/./node_modules/@microchip/scf-interface/lib/index.js","webpack://autoCreator/./node_modules/@microchip/scf-validators/lib/Validators/CFunctionValidator.js","webpack://autoCreator/./node_modules/@microchip/scf-validators/lib/Validators/HeaderPathValidator.js","webpack://autoCreator/./node_modules/@microchip/scf-validators/lib/Validators/HexValidator.js","webpack://autoCreator/./node_modules/@microchip/scf-validators/lib/index.js","webpack://autoCreator/webpack/bootstrap","webpack://autoCreator/webpack/runtime/define property getters","webpack://autoCreator/webpack/runtime/hasOwnProperty shorthand","webpack://autoCreator/webpack/runtime/make namespace object","webpack://autoCreator/./src/CreatorFunctions.ts","webpack://autoCreator/./src/DerivedData.ts","webpack://autoCreator/./generated_module/src/getUserData.ts","webpack://autoCreator/./generated_module/src/autoCreator.ts"],"sourcesContent":["\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar InterfaceTypes = __importStar(require(\"@microchip/scf-interface\"));\nvar pkgJson = __importStar(require(\"../package.json\"));\nvar i2c_client = __importStar(require(\"@microchip/i2c-client-basic\"));\nvar getInterfaceId = function () {\n    return {\n        name: InterfaceTypes.getInterfaceName(pkgJson),\n        version: InterfaceTypes.getInterfaceVersion(pkgJson),\n    };\n};\nvar createMock = function () {\n    return {\n        interfaceId: exports.Interface.getInterfaceId(),\n        payload: {\n            customName: \"I2C1\",\n            moduleInstance: 1,\n            moduleName: \"I2C1\",\n            clockStretching: true,\n            isClockStrechAlwaysEnabled: true,\n            clientAddress: 0x23,\n            clientMask: 0x23,\n            minClientAddress: 0x01,\n            maxClientAddress: 0x7f,\n            maxClientMask: 0x7f,\n            hasInterrupts: true,\n            interruptDriven: true,\n            i2cClientCallbackEvent: {\n                name: \"i2cClientCallback\",\n                header: \"./header/header.h\",\n            },\n            interfaceApi: i2c_client.getI2CInterfaceApiStructure(\"I2C1\"),\n        },\n        args: {\n            requestId: {\n                customName: \"I2C1\",\n                clockStretching: true,\n                clientAddress: 0x23,\n                clientMask: 0x23,\n                interruptDriven: true,\n                i2cClientCallbackEvent: {\n                    name: \"i2cClientCallback\",\n                    header: \"./header/header.h\",\n                },\n            },\n        },\n    };\n};\nvar createPrototypeImport = function () {\n    return {\n        interfaceId: getInterfaceId(),\n    };\n};\nvar createPrototypeExport = function () {\n    return {\n        interfaces: [{ interfaceId: getInterfaceId() }],\n    };\n};\nexports.Interface = {\n    createPrototypeExport: createPrototypeExport,\n    createPrototypeImport: createPrototypeImport,\n    getInterfaceId: getInterfaceId,\n    createMock: createMock,\n};\n//# sourceMappingURL=i2c-client-basic-drv-interface.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar i2c_client_basic_drv_interface_1 = require(\"./i2c-client-basic-drv-interface\");\nexports.Interface = i2c_client_basic_drv_interface_1.Interface;\nvar i2c_client_basic_1 = require(\"@microchip/i2c-client-basic\");\nexports.getI2CInterfaceApiStructure = i2c_client_basic_1.getI2CInterfaceApiStructure;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getI2CAPI = function () {\n    return {\n        Initialize: {\n            name: \"Initialize\",\n            returns: \"void\",\n        },\n        Deinitialize: {\n            name: \"Deinitialize\",\n            returns: \"void\",\n        },\n        ReadByte: {\n            name: \"ReadByte\",\n            returns: \"uint8_t\",\n        },\n        WriteByte: {\n            name: \"WriteByte\",\n            returns: \"void\",\n            arguments: [\n                { type: \"uint8_t\", name: \"wrByte\" },\n            ],\n        },\n        ErrorGet: {\n            name: \"ErrorGet\",\n            returns: \"enum I2C_CLIENT_ERROR\",\n        },\n        IsBusy: {\n            name: \"IsBusy\",\n            returns: \"bool\",\n        },\n        TransferDirGet: {\n            name: \"TransferDirGet\",\n            returns: \"enum I2C_CLIENT_TRANSFER_DIR\",\n        },\n        LastByteAckStatusGet: {\n            name: \"LastByteAckStatusGet\",\n            returns: \"enum I2C_CLIENT_ACK_STATUS\",\n        },\n        ClientCallbackRegister: {\n            name: \"ClientCallbackRegister\",\n            returns: \"void\",\n            arguments: [{ type: \"bool (*callback)(enum I2C_CLIENT_TRANSFER_EVENT)\", name: \"callback\" }],\n        },\n        Tasks: {\n            name: \"Tasks\",\n            returns: \"void\",\n        },\n    };\n};\nexports.getI2CHeaderFileData = function (moduleName) {\n    return [\n        {\n            name: moduleName.toLowerCase() + \".h\",\n            path: \"mcc_generated_files/i2c_client/\",\n        },\n        { name: \"i2c_client_interface\" + \".h\", path: \"mcc_generated_files/i2c_client/\" },\n    ];\n};\n//# sourceMappingURL=api.js.map","\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar InterfaceTypes = __importStar(require(\"@microchip/scf-interface\"));\nvar pkgJson = __importStar(require(\"../package.json\"));\nvar api_1 = require(\"./api\");\nexports.getI2CInterfaceApiStructure = function (moduleName) {\n    return {\n        api: api_1.getI2CAPI(),\n        headerFiles: api_1.getI2CHeaderFileData(moduleName),\n    };\n};\nvar getInterfaceId = function () {\n    return {\n        name: InterfaceTypes.getInterfaceName(pkgJson),\n        version: InterfaceTypes.getInterfaceVersion(pkgJson),\n    };\n};\nvar createMock = function () {\n    return {\n        interfaceId: exports.Interface.getInterfaceId(),\n        payload: {\n            moduleInstance: 1,\n            moduleName: \"I2C1\",\n            clockStretching: true,\n            isClockStrechAlwaysEnabled: true,\n            clientAddress: 0x23,\n            clientMask: 0x23,\n            minClientAddress: 0x01,\n            maxClientAddress: 0x7f,\n            maxClientMask: 0x7f,\n            hasInterrupts: true,\n            interruptDriven: true,\n            i2cClientCallbackEvent: {\n                name: \"i2cClientCallback\",\n                header: \"./header/header.h\",\n            },\n            interfaceApi: exports.getI2CInterfaceApiStructure(\"I2C1\"),\n        },\n        args: {\n            requestId: {\n                clockStretching: true,\n                clientAddress: 0x23,\n                clientMask: 0x23,\n                interruptDriven: true,\n                i2cClientCallbackEvent: {\n                    name: \"i2cClientCallback\",\n                    header: \"./header/header.h\",\n                },\n            },\n        },\n    };\n};\nvar createPrototypeImport = function () {\n    return {\n        interfaceId: getInterfaceId(),\n    };\n};\nvar createPrototypeExport = function () {\n    return {\n        interfaces: [{ interfaceId: getInterfaceId() }],\n    };\n};\nexports.Interface = {\n    createPrototypeExport: createPrototypeExport,\n    createPrototypeImport: createPrototypeImport,\n    getInterfaceId: getInterfaceId,\n    createMock: createMock,\n};\n//# sourceMappingURL=i2c-client-basic.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar i2c_client_basic_1 = require(\"./i2c-client-basic\");\nexports.Interface = i2c_client_basic_1.Interface;\nexports.getI2CInterfaceApiStructure = i2c_client_basic_1.getI2CInterfaceApiStructure;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildSimpleApi = function (functions) {\n    var api = {};\n    for (var key in functions) {\n        api[key] = buildFunction(functions[key]);\n    }\n    return api;\n};\nvar buildFunction = function (cFunction) {\n    return cFunction.returns + \" \" + cFunction.name + \"(\" + buildArguments(cFunction.arguments) + \")\";\n};\nvar buildArguments = function (args) {\n    if (args) {\n        return args.map(function (arg) { return arg.type + \" \" + arg.name; }).join(\", \");\n    }\n    else {\n        return \"void\";\n    }\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getInterfaceName = function (pkgJson) {\n    var strReplace = \"@microchip/\";\n    var interfaceName;\n    if (pkgJson) {\n        interfaceName = pkgJson[\"name\"];\n        if (interfaceName) {\n            interfaceName = interfaceName.replace(strReplace, \"\");\n        }\n    }\n    if (!interfaceName) {\n        throw new Error(\"Invalid Interface Name...!\");\n    }\n    return interfaceName;\n};\nexports.getInterfaceVersion = function (pkgJson) {\n    var versionRegex = new RegExp(\"\\\\d+.\\\\d+.\\\\d+\");\n    var version;\n    if (pkgJson) {\n        version = pkgJson[\"version\"];\n    }\n    if (!version && !versionRegex.test(version)) {\n        throw new Error(\"Invalid Interface Version...!\");\n    }\n    return version;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar c_function_types_1 = require(\"./c-function-types\");\nexports.buildSimpleApi = c_function_types_1.buildSimpleApi;\nvar helpers_1 = require(\"./helpers\");\nexports.getInterfaceName = helpers_1.getInterfaceName;\nexports.getInterfaceVersion = helpers_1.getInterfaceVersion;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCFunctionValidator = void 0;\nvar cKeywords = [\n    \"auto\",\n    \"const\",\n    \"double\",\n    \"float\",\n    \"int\",\n    \"short\",\n    \"struct\",\n    \"unsigned\",\n    \"break\",\n    \"continue\",\n    \"else\",\n    \"for\",\n    \"long\",\n    \"signed\",\n    \"switch\",\n    \"void\",\n    \"case\",\n    \"default\",\n    \"enum\",\n    \"goto\",\n    \"register\",\n    \"sizeof\",\n    \"typedef\",\n    \"volatile\",\n    \"char\",\n    \"do\",\n    \"extern\",\n    \"if\",\n    \"return\",\n    \"static\",\n    \"union\",\n    \"while\",\n];\nvar functionPattern = \"(?=^([A-Za-z]\\\\S|_)\\\\w+$)\";\nvar errorMessage = \"Must be valid C function syntax.\";\nvar doNotMatchKeywordsRegex = function () {\n    return \"(^(?!\" + cKeywords.join(\"|\") + \")).*\";\n};\nvar result = doNotMatchKeywordsRegex();\nvar pattern = {\n    pattern: functionPattern + result,\n};\nexports.getCFunctionValidator = function () { return ({\n    getRjsfValidation: function () { return pattern; },\n    getCustomErrorMessage: function () { return errorMessage; },\n    getValidation: function () { return ({\n        name: \"pattern\",\n        message: exports.getCFunctionValidator().getCustomErrorMessage(),\n    }); },\n}); };\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getHeaderPathValidator = void 0;\n//Matches file paths to any valid format. Matches both \"\\\" and \"/\" as valid separators in file path.\n//Extension (\"[h]+\") checks specifically for '.h' and can be extende to any if required.\n//Does NOT match relative file paths.\nvar pathRegex = \"^(([a-zA-Z]:)|((?:\\\\\\\\|.\\\\/?){1,2}\\\\w+)\\\\$?)((\\\\\\\\|\\\\/)(\\\\w[\\\\w ]*.*))+\\\\.([h]+)$\";\nvar errorMessage = \"Must be valid header path.\";\nvar pathPattern = {\n    pattern: pathRegex,\n};\nexports.getHeaderPathValidator = function () { return ({\n    getRjsfValidation: function () { return pathPattern; },\n    getCustomErrorMessage: function () { return errorMessage; },\n    getValidation: function () { return ({\n        name: \"pattern\",\n        message: exports.getHeaderPathValidator().getCustomErrorMessage(),\n    }); },\n}); };\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getHexValidator = void 0;\nvar regexFormat = /^0x[\\da-f]/i;\nvar ErrorMessages;\n(function (ErrorMessages) {\n    ErrorMessages[\"Format\"] = \"Must be valid hexadecimal number\";\n    ErrorMessages[\"Bounds\"] = \"Input must be \";\n    ErrorMessages[\"BoundsDefault\"] = \"Input must be within bounds\";\n})(ErrorMessages || (ErrorMessages = {}));\nvar format = {\n    hex: regexFormat,\n};\nexports.getHexValidator = function () { return ({\n    getRjsfValidation: function () { return format; },\n    getInvalidFormatErrorMessage: function () { return ErrorMessages.Format; },\n    getBoundsErrorMessage: function (comparison, value) {\n        return comparison && value\n            ? ErrorMessages.Bounds + comparison + \" \" + value\n            : ErrorMessages.BoundsDefault;\n    },\n    getFormatValidation: function () { return ({\n        name: \"format\",\n        message: exports.getHexValidator().getInvalidFormatErrorMessage(),\n    }); },\n    getMinValidation: function (comparison, value) { return ({\n        name: \"minimum\",\n        message: \"\" + exports.getHexValidator().getBoundsErrorMessage(comparison, value),\n    }); },\n    getMaxValidation: function (comparison, value) { return ({\n        name: \"maximum\",\n        message: \"\" + exports.getHexValidator().getBoundsErrorMessage(comparison, value),\n    }); },\n}); };\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar CFunctionValidator_1 = require(\"./Validators/CFunctionValidator\");\nObject.defineProperty(exports, \"getCFunctionValidator\", { enumerable: true, get: function () { return CFunctionValidator_1.getCFunctionValidator; } });\nvar HexValidator_1 = require(\"./Validators/HexValidator\");\nObject.defineProperty(exports, \"getHexValidator\", { enumerable: true, get: function () { return HexValidator_1.getHexValidator; } });\nvar HeaderPathValidator_1 = require(\"./Validators/HeaderPathValidator\");\nObject.defineProperty(exports, \"getHeaderPathValidator\", { enumerable: true, get: function () { return HeaderPathValidator_1.getHeaderPathValidator; } });\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { CreatorFunctions } from \"@microchip/melody-automodule-interface\";\nimport { MyState } from \"../generated_module/src/types/AutoModuleTypes\";\n\nexport const getCreatorFunctions = (): CreatorFunctions => {\n    return {\n        shouldImport: shouldImport,\n        getCreatorImportArgs: getCreatorImportArgs,\n    };\n};\n\nconst shouldImport = (importKey: string, state: MyState): boolean => {\n    return true;\n};\n\nconst getCreatorImportArgs = (importKey: string, state: MyState): any | undefined => {\n    return undefined;\n};\n","import * as Processor from \"@microchip/scf-common/lib/Processor\";\nimport * as i2c_client_basic from \"@microchip/i2c-client-basic\";\nimport {\n    getCFunctionValidator,\n    PatternValidator,\n    HexValidator,\n    getHexValidator,\n} from \"@microchip/scf-validators/lib\";\nimport {\n    AppModel,\n    DerivedData,\n    DerivedFunctions,\n} from \"../generated_module/src/types/AutoModuleTypes\";\nimport { MyImports } from \"../generated_module/src/types\";\nimport { Help } from \"@microchip/scf-common/lib/PackageJsonConfiguration\";\nimport { ExportArg } from \"@microchip/melody-automodule-interface/lib/src/InterfaceTypes\";\nimport * as i2c_client_basic_drv from \"@microchip/i2c-client-basic-drv-interface\";\n\nconst I2C_CLIENT_BASIC = \"i2c_client_basic\";\nconst I2C_CLIENT_BASIC_DRV_INTF = \"i2c-client-basic-drv-interface\";\nconst CUSTOM_NAME_COMPONENT = \"customName\";\nconst CLOCK_STRETCHING_COMPONENT = \"clockStretching\";\nconst CLIENT_ADDRESS_COMPONENT = \"clientAddress\";\nconst CLIENT_MASK_COMPONENT = \"clientMask\";\n\nexport const getDerivedData = (dataModel: AppModel): DerivedData => {\n    if (dataModel) {\n        return new MyDerivedData(dataModel);\n    }\n    return new EmptyDerivedData();\n};\n\n//This data will be used at the creator stage and relies on only the state\nclass EmptyDerivedData implements DerivedData {\n    getMyFunctions = (): DerivedFunctions => {\n        return {};\n    };\n    getModel = (): AppModel | undefined => {\n        return undefined;\n    };\n}\n\n//This data will be used at the processor stage\nclass MyDerivedData implements DerivedData {\n    private dataModel: AppModel;\n    private cValidator: PatternValidator = getCFunctionValidator();\n\n    constructor(dataModel: AppModel) {\n        this.dataModel = dataModel;\n    }\n\n    getMyFunctions = (): DerivedFunctions => {\n        return {\n            moduleName: this.getModuleName,\n            templateData: this.getMyTemplateData,\n            alerts: this.getMyAlerts,\n            getActiveName: this.getActiveName,\n            getCustomUiErrors: this.getCustomUiErrors,\n            importName: this.friendlyImportName,\n            filterImports: this.filterMyImports,\n            importOptionLabel: this.friendlyImportOptionLabels,\n            customNameValidator: this.customNameValidator,\n            clientAddressValidator: this.clientAddressValidator,\n            clientMaskValidator: this.clientMaskValidator,\n            i2c_client_basic_args: this.getArguments,\n            i2c_client_basic_results: this.getResults,\n            overrideDefaultValues: this.overrideDefaultValue,\n            isEnabled: this.isEnabled,\n            overrideModuleLevelHelp: this.overrideModuleLevelHelp,\n            getUiBehavior: this.getUiBehavior,\n            \"i2c-client-basic-drv-interface_payload\": this.getI2cClientDrvPayload,\n        };\n    };\n\n    public getI2cClientDrvPayload = (): i2c_client_basic_drv.Payload | undefined => {\n        const interfaceData = this.dataModel.getImportValue(\"i2c_client_basic\");\n        if (interfaceData != undefined) {\n            return {\n                ...interfaceData,\n                customName: this.dataModel.getComponentValue(\"customName\"),\n            };\n        }\n    };\n\n    public getUiBehavior = (component: string): any => {\n        let uiBehavior = {};\n        if (this.getRequestedArg(component, I2C_CLIENT_BASIC_DRV_INTF)) {\n            switch (component) {\n                case CUSTOM_NAME_COMPONENT:\n                case CLIENT_ADDRESS_COMPONENT:\n                case CLIENT_MASK_COMPONENT:\n                    uiBehavior = {\n                        [\"ui:help\"]: this.getUiBehaviorStrField(component),\n                    };\n                    break;\n                case CLOCK_STRETCHING_COMPONENT: {\n                    uiBehavior = {\n                        [\"ui:help\"]: this.getUiBehaviorBooleanField(component),\n                    };\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n        return uiBehavior;\n    };\n    public getUiBehaviorStrField = (component: string): string => {\n        let reqField = this.getRequestedArg(component, I2C_CLIENT_BASIC_DRV_INTF)?.value;\n        if (component != CUSTOM_NAME_COMPONENT) {\n            reqField = \"0x\" + reqField.toString(16);\n        }\n        const setField = this.dataModel.getComponentValue(component);\n\n        if (reqField != undefined && setField != undefined && reqField != setField) {\n            return (\n                \"Configure field to \" +\n                reqField +\n                \" to match with value requested by dependent module\"\n            );\n        }\n        return \"Field is being set by dependent module, any updates will override preconfigured value\";\n    };\n\n    public getUiBehaviorBooleanField = (component: string): string => {\n        const reqField = this.getRequestedArg(\n            component,\n            I2C_CLIENT_BASIC_DRV_INTF,\n        )?.value;\n        const setField = this.dataModel.getComponentValue(component);\n        if (reqField != undefined && setField != undefined && reqField != setField) {\n            let strType = \"Enable\";\n            if (reqField == false) {\n                strType = \"Disable\";\n            }\n            return (\n                strType + \" field to\" + \" match with value requested by dependent module\"\n            );\n        }\n        return \"Field is being set by dependent module, any updates will override preconfigured value\";\n    };\n\n    private getRequestedArg = (\n        componentName: string,\n        interfaceName: string,\n    ): ExportArg | undefined => {\n        const exportData = this.dataModel?.getExportInterfaces()?.getInterfaceData();\n        if (exportData != undefined) {\n            for (let i = 0; i < exportData.length; i++)\n                if (\n                    exportData[i].interface === interfaceName &&\n                    exportData[i].name === componentName\n                ) {\n                    return exportData[i];\n                }\n        }\n        return undefined;\n    };\n\n    private overrideModuleLevelHelp = (): Help => {\n        const deviceMeta = this.dataModel.getImportValue(\"device_meta\");\n        const deviceName = deviceMeta?.architecture;\n        let url = \"\";\n        let tooltip = \"\";\n\n        if (deviceName === \"PIC16\" || deviceName === \"PIC18\") {\n            url =\n                \"v2/keyword-lookup?keyword=SCF-PIC8-I2C-CLIENT&version=latest&redirect=true\";\n            tooltip = \"I2C Client Driver for 8-bit PIC devices\";\n        } else if (deviceName === \"AVR8\" || deviceName === \"AVR8X\") {\n            url =\n                \"v2/keyword-lookup?keyword=SCF-AVR8-I2C-CLIENT&version=latest&redirect=true\";\n            tooltip = \"I2C Client Driver for 8-bit AVR devices\";\n        } else if (deviceName === \"DSPIC33A\") {\n            url =\n                \"v2/keyword-lookup?keyword=I2C_CLIENT_33A_MELODY_DRIVER&version=latest&redirect=true\";\n            tooltip = \"Click here to open I2C API documentation.\";\n        } else if (deviceName === undefined) {\n            url = \"\";\n            tooltip = \"Load I2C Client Driver to view help.\";\n        } else {\n            url =\n                \"v2/keyword-lookup?keyword=I2C_Client_Melody_Driver&version=latest&redirect=true\";\n            tooltip = \"I2C Client driver for 16-bit PIC and dsPIC devices\";\n        }\n\n        return {\n            url: url,\n            tooltip: tooltip,\n        };\n    };\n\n    private isEnabled = (componentName: string): boolean | undefined => {\n        const processedPayloadVal: i2c_client_basic.ProcessedPayload =\n            this.dataModel.getImportValue(I2C_CLIENT_BASIC);\n        let enableStatus: boolean | undefined = false;\n        switch (componentName) {\n            case \"clockStretching\":\n                if (processedPayloadVal) {\n                    if (processedPayloadVal.isClockStrechAlwaysEnabled) {\n                        enableStatus = !processedPayloadVal.isClockStrechAlwaysEnabled;\n                    } else {\n                        enableStatus = true;\n                    }\n                } else {\n                    enableStatus = true;\n                }\n                break;\n            default:\n                enableStatus = undefined;\n                break;\n        }\n        return enableStatus;\n    };\n\n    private clientAddressValidator = (): any => {\n        const processedPayloadVal: i2c_client_basic.ProcessedPayload =\n            this.dataModel.getImportValue(I2C_CLIENT_BASIC);\n        return {\n            maximum: processedPayloadVal?.maxClientAddress ?? 0x3ff,\n            minimum: processedPayloadVal?.minClientAddress ?? 0x00,\n        };\n    };\n\n    private clientMaskValidator = (): any => {\n        const processedPayloadVal: i2c_client_basic.ProcessedPayload =\n            this.dataModel.getImportValue(I2C_CLIENT_BASIC);\n        return {\n            maximum: processedPayloadVal?.maxClientMask ?? 0x3ff,\n            minimum: 0x00,\n        };\n    };\n\n    private overrideDefaultValue = (componentName: string): any => {\n        let processedPayloadVal;\n        switch (componentName) {\n            case CUSTOM_NAME_COMPONENT:\n                {\n                    const customName = this.getRequestedArg(\n                        \"customName\",\n                        I2C_CLIENT_BASIC_DRV_INTF,\n                    )?.value;\n                    if (customName != undefined) {\n                        return customName;\n                    } else {\n                        processedPayloadVal =\n                            this.dataModel.getImportValue(I2C_CLIENT_BASIC);\n                        if (processedPayloadVal?.moduleInstance != undefined) {\n                            return \"I2C\" + processedPayloadVal.moduleInstance + \"_Client\";\n                        }\n                    }\n                }\n                break;\n            case CLOCK_STRETCHING_COMPONENT:\n                return this.getRequestedArg(\"clockStretching\", I2C_CLIENT_BASIC_DRV_INTF)\n                    ?.value;\n            case CLIENT_ADDRESS_COMPONENT:\n                return this.getRequestedArg(\"clientAddress\", I2C_CLIENT_BASIC_DRV_INTF)\n                    ?.value;\n            case CLIENT_MASK_COMPONENT:\n                {\n                    const requestedClientMask = this.getRequestedArg(\n                        \"clientMask\",\n                        I2C_CLIENT_BASIC_DRV_INTF,\n                    )?.value;\n                    if (requestedClientMask !== undefined) {\n                        return requestedClientMask;\n                    } else {\n                        processedPayloadVal =\n                            this.dataModel.getImportValue(I2C_CLIENT_BASIC);\n                        if (processedPayloadVal?.clientMask != undefined) {\n                            return processedPayloadVal.clientMask;\n                        }\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n        return undefined;\n    };\n\n    public getModuleName = (): string | undefined => {\n        return this.dataModel?.getComponentValue(\"customName\");\n    };\n\n    private getActiveName = (): string | undefined => {\n        const processedPayloadVal: i2c_client_basic.ProcessedPayload =\n            this.dataModel.getImportValue(I2C_CLIENT_BASIC);\n        if (processedPayloadVal?.moduleName) {\n            return this.dataModel?.getComponentValue(\"customName\");\n        }\n        return this.dataModel?.getComponentValue(\"customName\") + \" (None)\";\n    };\n\n    private customNameValidator = (): any => {\n        return {\n            pattern: this.cValidator.getRjsfValidation().pattern,\n        };\n    };\n\n    private getCustomUiErrors = (componentName: string): Error[] | undefined => {\n        const hexValidator: HexValidator = getHexValidator();\n        const processedPayloadVal: i2c_client_basic.ProcessedPayload =\n            this.dataModel.getImportValue(I2C_CLIENT_BASIC);\n\n        switch (componentName) {\n            case \"customName\":\n                return [\n                    {\n                        name: \"pattern\",\n                        message: this.cValidator.getCustomErrorMessage(),\n                    },\n                ];\n\n            case \"clientMask\":\n                return [\n                    hexValidator.getMinValidation(\">=\", \"0x0\"),\n                    hexValidator.getMaxValidation(\n                        \"less than\",\n                        processedPayloadVal?.maxClientMask?.toString() ?? \"0x3FF\",\n                    ),\n                    hexValidator.getFormatValidation(),\n                ];\n            case \"clientAddress\":\n                return [\n                    hexValidator.getMinValidation(\n                        \">=\",\n                        processedPayloadVal?.minClientAddress?.toString() ?? \"0x0\",\n                    ),\n                    hexValidator.getMaxValidation(\n                        \"less than\",\n                        processedPayloadVal?.maxClientAddress?.toString() ?? \"0x3FF\",\n                    ),\n                    hexValidator.getFormatValidation(),\n                ];\n            default:\n                return undefined;\n        }\n    };\n\n    private filterMyImports = (imports: MyImports): MyImports => {\n        const filteredImports: MyImports = this.dataModel?.filterImportBySetting(\n            imports,\n            I2C_CLIENT_BASIC,\n            (option: Processor.Option<any>): boolean => {\n                return true;\n            },\n        );\n        if (filteredImports?.i2c_client_basic?.options) {\n            filteredImports.i2c_client_basic.options.sort(\n                (importOption1, importOption2) =>\n                    importOption1.payload.moduleInstance >\n                    importOption2.payload.moduleInstance\n                        ? 1\n                        : -1,\n            );\n        }\n        return filteredImports;\n    };\n\n    private friendlyImportName = (importKey: string): string | undefined => {\n        if (importKey === I2C_CLIENT_BASIC) {\n            return \"I2C Client\";\n        }\n        return undefined;\n    };\n\n    private friendlyImportOptionLabels = (\n        importKey: string,\n        option: Processor.Option,\n    ): string => {\n        if (importKey === I2C_CLIENT_BASIC && option?.payload?.moduleName) {\n            return option.payload.moduleName;\n        }\n        return \"I2C\";\n    };\n\n    private getArguments = (): i2c_client_basic.Arguments => {\n        return {\n            clockStretching: this.dataModel?.getComponentValue(\"clockStretching\"),\n            clientAddress: this.dataModel?.getComponentValue(\"clientAddress\"),\n            clientMask:\n                this.dataModel?.getState()?.main?.software?.clientMask ??\n                this.getRequestedArg(\"clientMask\", I2C_CLIENT_BASIC_DRV_INTF)?.value,\n            interruptDriven: this.getRequestedArg(\n                \"interruptDriven\",\n                I2C_CLIENT_BASIC_DRV_INTF,\n            )?.value,\n            getInterfaceAPI: this.getRequestedArg(\n                \"getInterfaceAPI\",\n                I2C_CLIENT_BASIC_DRV_INTF,\n            )?.value,\n            i2cClientCallbackEvent: this.getRequestedArg(\n                \"i2cClientCallbackEvent\",\n                I2C_CLIENT_BASIC_DRV_INTF,\n            )?.value,\n        };\n    };\n\n    private getResults = (): i2c_client_basic.Results => {\n        return {\n            customName: this.dataModel?.getComponentValue(\"customName\"),\n            plibRequests: this.getPlibRequestsFromI2cClientDrvIntf(),\n        };\n    };\n    private getPlibRequestsFromI2cClientDrvIntf = ():\n        | i2c_client_basic_drv.results\n        | undefined => {\n        const resultsMap = this.dataModel\n            ?.getExportInterfaces()\n            ?.getInterface(\n                \"i2c_client_basic_drv_interface\",\n                i2c_client_basic_drv.Interface.getInterfaceId(),\n            )?.results;\n\n        if (resultsMap != undefined) {\n            for (const moduleId in resultsMap) {\n                const plibRequest = resultsMap[moduleId]?.plibRequests;\n                if (plibRequest) {\n                    return plibRequest;\n                }\n            }\n        }\n        return undefined;\n    };\n    public getModel = (): AppModel => {\n        return this.dataModel;\n    };\n\n    private getMyTemplateData = (): any => {\n        return {};\n    };\n\n    private getMyAlerts = (): Processor.Alert[] => {\n        return [];\n    };\n}\n","import { ModuleConfig } from \"@microchip/melody-automodule-interface/lib/src/ModuleConfig\";\nimport { PinsData } from \"@microchip/melody-automodule-interface/lib/src/pins\";\nimport { PinsLogic } from \"@microchip/melody-automodule-interface/lib/src/types\";\nexport { getCreatorFunctions } from \"../../src/CreatorFunctions\";\nexport { getDerivedData } from \"../../src/DerivedData\";\n\nexport const getPinsDataFromFile = (): PinsData | undefined => {\n    try {\n        return require(\"../../src/pinsdata.json\");\n    } catch {\n        return undefined;\n    }\n};\n\nexport const getPinsLogicFromFile = (): PinsLogic | undefined => {\n    try {\n        return require(\"../../src/PinsLogic.ts\");\n    } catch {\n        return undefined;\n    }\n};\n\nexport const getModuleConfigFromFile = (): ModuleConfig | undefined => {\n    try {\n        return require(\"../../src/moduleConfig.json\");\n    } catch {\n        return undefined;\n    }\n};\n","import { CreatorFunctions } from \"@microchip/melody-automodule-interface\";\nimport {\n    getCreatorFunctions as getCreatorFunctionsUser,\n    getModuleConfigFromFile,\n} from \"./getUserData\";\n\nconst createAutoCreator = (\n    getCreatorFunctions: () => CreatorFunctions,\n): (() => CreatorFunctions) => {\n    return (): CreatorFunctions => {\n        return {\n            getModuleConfig: getModuleConfigFromFile,\n            ...getCreatorFunctions(),\n        };\n    };\n};\n\nexport const getCreatorFunctions = createAutoCreator(getCreatorFunctionsUser);\n"],"names":["__importStar","this","mod","__esModule","result","k","Object","hasOwnProperty","call","defineProperty","exports","value","InterfaceTypes","pkgJson","i2c_client","getInterfaceId","name","getInterfaceName","version","getInterfaceVersion","Interface","createPrototypeExport","interfaces","interfaceId","createPrototypeImport","createMock","payload","customName","moduleInstance","moduleName","clockStretching","isClockStrechAlwaysEnabled","clientAddress","clientMask","minClientAddress","maxClientAddress","maxClientMask","hasInterrupts","interruptDriven","i2cClientCallbackEvent","header","interfaceApi","getI2CInterfaceApiStructure","args","requestId","getI2CAPI","Initialize","returns","Deinitialize","ReadByte","WriteByte","arguments","type","ErrorGet","IsBusy","TransferDirGet","LastByteAckStatusGet","ClientCallbackRegister","Tasks","getI2CHeaderFileData","toLowerCase","path","api_1","api","headerFiles","i2c_client_basic_1","buildSimpleApi","functions","key","buildFunction","cFunction","buildArguments","map","arg","join","interfaceName","replace","Error","versionRegex","RegExp","test","c_function_types_1","helpers_1","getCFunctionValidator","pattern","getRjsfValidation","getCustomErrorMessage","getValidation","message","getHeaderPathValidator","pathPattern","getHexValidator","ErrorMessages","format","hex","getInvalidFormatErrorMessage","Format","getBoundsErrorMessage","comparison","Bounds","BoundsDefault","getFormatValidation","getMinValidation","getMaxValidation","CFunctionValidator_1","HexValidator_1","HeaderPathValidator_1","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","module","__webpack_modules__","d","definition","o","enumerable","get","obj","prop","prototype","r","Symbol","toStringTag","shouldImport","importKey","state","getCreatorImportArgs","getModuleConfigFromFile","require","getCreatorFunctions","getModuleConfig","createAutoCreator"],"sourceRoot":""}