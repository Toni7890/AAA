
import { TestCaseAPIs } from "@microchip/ccl-itf/lib/apis/TestCaseAPIs";
import { ReportAPIs } from "@microchip/ccl-itf/lib/apis/ReportAPIs";
import  * as  utils from "./Utils";

const addMsg = require("@microchip/melody-itf-reporters/lib/helper").addMsg;
const itfConfig = require("../../reports/itf.config.json"); // This file is automatically generated by CCL-ITF.
 
let testAPI: TestCaseAPIs;
let reportAPI: ReportAPIs;
const devices: string[] = itfConfig.devices;
const runDir: string = itfConfig.runDir;
const MAX_LAUNCH_TIMEOUT = 1000000; // in ms
const MAX_TESTCASE_TIMEOUT = 700000; // in ms
const MAX_CMD_TIMEOUT = 90000; // in ms (this is optional, default is 60000ms);
const importInterface ="i2c_client_basic";

let PLIBmoduleId = '';
let driverModuleId = '';
const PLIBmoduleInfo = {
    name: '@mchp-mcc/pic24-dspic33-i2c-upb',
    version: '>=1.0.0'
}
const driverModuleInfo = {
    name: '@mchp-mcc/i2c-client-driver',
    version: '>=1.0.0'
}
const interfaceInfo ={
        name: "i2c-client-basic",
        version: ">= 2.0.0 < 4.0.0"
};
const loadModulebyId = async () => {
    let moduleIds = await testAPI.getModuleIdsforInterface(driverModuleInfo);
    expect(moduleIds.length).toBeGreaterThan(0);
    driverModuleId=moduleIds[0];
    expect(await testAPI.loadModule(driverModuleId, MAX_CMD_TIMEOUT)).toBe(true);
    const options = await testAPI.getOptionsForImportInterfaceId(driverModuleId, interfaceInfo);
    if (options.length > 0) {
        expect(options.length).toBeGreaterThan(0);
        expect(await testAPI.setImportInterfaceIdByOption(driverModuleId, interfaceInfo, options[0])).toBeTruthy();
        PLIBmoduleId = options[0];
    }

    if (options.length <= 0) {
        const PLIBModule = await testAPI.getModuleIdsforInterface(PLIBmoduleInfo);
        expect(PLIBModule.length).toBeGreaterThan(0);
        PLIBmoduleId = PLIBModule[0];
    }
};
const setup = async () => {
    try {
        testAPI = new TestCaseAPIs();
        reportAPI = new ReportAPIs();
        await testAPI.setup(runDir);
        await reportAPI.setup(runDir);
    } catch (e) {
        throw e;
    }
}

/*
* Test cases
*/
describe("i2c-client driver", () => {
    beforeAll(async () => {
        await setup();
        await testAPI.start();
    }, MAX_LAUNCH_TIMEOUT);
 
    afterAll(async () => {
        await testAPI.close();
    });
 
    beforeEach(async () => {
        await reportAPI.cleanupLog();
    });
 
    afterEach(async () => {     
        const log: string = await reportAPI.getLogData();
        await addMsg(log);
    });

 
//Module testcases
describe.each(devices)("%s", (device) => {
    describe("TID_1 Basic testing", () => {
        test("TID_1-1 Load Module and generate code with default setting", async () => {
            expect(await testAPI.loadDevice(device)).toBe(true);
            await loadModulebyId();
            expect(await testAPI.generateCode()).toBe(true);
            const projectName = `${device}.default.i2c-client.X`;
            expect(await testAPI.saveProjectAs(projectName, true)).toBe(true);
        },MAX_TESTCASE_TIMEOUT);
        test("TID_1-2 Unload module by moduleID", async () => {                 
            expect(await testAPI.unloadModule(driverModuleId,MAX_CMD_TIMEOUT)).toBe(true);   
        }, MAX_TESTCASE_TIMEOUT);
        // Changing the custom name only for driver
        test("TID_1-3 Changing the custom name", async () => {
            await loadModulebyId();
            await testAPI.setAutoModuleProperty(driverModuleId, 'main', 'software.customName','userCustomName');
            expect(await testAPI.assertAutoModuleProperty(driverModuleId, 'main', 'software.customName','userCustomName')).toBeTruthy();
            const driverData = await testAPI.getModuleData(driverModuleId);
            expect(utils.getResult(driverData,importInterface,"customName")).toBe("userCustomName");
            expect(driverData?.name).toBe("userCustomName");
        },MAX_TESTCASE_TIMEOUT);   
        });

    });

});